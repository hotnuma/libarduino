Seulement dans gpsFreq-master/: .gitignore
diff -rup -w gpsFreq-master/src/gpsFreq.cpp gpsFreq-new/src/gpsFreq.cpp
--- gpsFreq-master/src/gpsFreq.cpp	2022-01-30 00:06:39.000000000 +0100
+++ gpsFreq-new/src/gpsFreq.cpp	2026-02-11 16:30:53.111290892 +0100
@@ -15,10 +15,13 @@
 void FreqCounter::start(uint8_t gatePeriod)
 {
     isBusy = true;
+    digitalWrite(LED_BUILTIN, HIGH);
+    
     m_gatePeriod = gatePeriod;
     m_gateInterrupts = 0;
 
-    //TIMSK0 &= ~_BV(TOIE0);  // disable timer 0 overflow interrupt -- disables millis(), delay()
+    TIMSK0 &= ~_BV(TOIE0);  // disable timer 0 overflow interrupt -- disables millis(), delay()
+    
     EICRA = _BV(ISC01);     // external interrupt on falling edge
     EIFR = _BV(INTF0);      // clear the interrupt flag (setting ISCnn can cause an interrupt)
     EIMSK = _BV(INT0);      // enable external interrupt
@@ -32,19 +35,29 @@ void FreqCounter::formatFreq(char* c)
     ltoa(freq / m_gatePeriod, f, 10);
     char* pf = f;
     uint8_t len = strlen(f);
-    for (uint8_t i=0; i<len; i++) {
+    
+    for (uint8_t i=0; i<len; i++)
+    {
         *c++ = *pf++;
-        if ((len - i - 1) % 3 == 0 && i < len-1) *c++ = ',';
+        
+        if ((len - i - 1) % 3 == 0 && i < len-1)
+            *c++ = ' ';
     }
 
-    if (m_gatePeriod > 1) {
+    if (m_gatePeriod > 1)
+    {
         itoa(freq % m_gatePeriod, f, 10);
         *c++ = '.';
-        if (strlen(f) < 2 && m_gatePeriod > 10) *c++ = '0';
+        
+        if (strlen(f) < 2 && m_gatePeriod > 10)
+            *c++ = '0';
+        
         pf = f;
+        
         while ( (*c++ = *pf++) );
     }
-    else {
+    else
+    {
         *c++ = 0;
     }
 }
@@ -53,7 +66,25 @@ FreqCounter gpsFreq;    // instantiate t
 
 ISR(INT0_vect)
 {
-    if (gpsFreq.m_gateInterrupts == 0) {    // start counting with the first interrupt
+    if (gpsFreq.m_gateInterrupts == gpsFreq.m_gatePeriod)
+    {
+        // time to stop counting?
+        
+        TCCR1B = 0;                     // stop timer 1
+        TIMSK1 = 0;                     // stop timer 1 overflow interrupt
+        EIMSK = 0;                      // stop external interrupt
+        
+        TIMSK0 |= _BV(TOIE0);           // enable timer 0 overflow interrupt
+        
+        gpsFreq.freq = ((uint32_t) gpsFreq.m_t1ovf << 16) + TCNT1;
+        
+        gpsFreq.isBusy = false;
+        digitalWrite(LED_BUILTIN, LOW);
+    }
+    else
+    {   
+        // start counting with the first interrupt
+        
         TCCR1B = 0;
         TCCR1A = 0;                     // stop timer 1
         TCCR1C = 0;
@@ -64,14 +95,7 @@ ISR(INT0_vect)
         TIMSK1 = _BV(TOIE1);            // interrupt on timer 1 overflow
         TCCR1B = _BV(CS12) | _BV(CS11); // start timer 1, external clock on falling edge
     }
-    else if (gpsFreq.m_gateInterrupts >= gpsFreq.m_gatePeriod) {    // time to stop counting?
-        TCCR1B = 0;                     // stop timer 1
-        TIMSK1 = 0;                     // stop timer 1 overflow interrupt
-        EIMSK = 0;                      // stop external interrupt
-        //TIMSK0 |= _BV(TOIE0);           // enable timer 0 overflow interrupt
-        gpsFreq.freq = ((uint32_t)gpsFreq.m_t1ovf << 16) + TCNT1;
-        gpsFreq.isBusy = false;
-    }
+    
     ++gpsFreq.m_gateInterrupts;
     ++gpsFreq.ppsTotal;
 }
@@ -80,3 +104,5 @@ ISR(TIMER1_OVF_vect)
 {
     ++gpsFreq.m_t1ovf;
 }
+
+
diff -rup -w gpsFreq-master/src/gpsFreq.h gpsFreq-new/src/gpsFreq.h
--- gpsFreq-master/src/gpsFreq.h	2022-01-30 00:06:39.000000000 +0100
+++ gpsFreq-new/src/gpsFreq.h	2026-02-01 20:42:10.853055066 +0100
@@ -11,12 +11,14 @@
 
 #ifndef GPSFREQ_H_INCLUDED
 #define GPSFREQ_H_INCLUDED
+
 #include <Arduino.h>
 
 class FreqCounter
 {
     public:
-        FreqCounter() {};                   // constructor
+    
+        FreqCounter() {    pinMode(LED_BUILTIN, OUTPUT);};                   // constructor
         void start(uint8_t gatePeriod);     // gatePeriod in seconds (1, 10, 100)
         void formatFreq(char* c);           // returns freq as a formatted string
         volatile bool isBusy;               // flag to indicate counting complete
